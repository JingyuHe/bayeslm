# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

# horseshoe <- function(Y, X, block_vec = NULL, sigma = NULL, s2 = 1, kap2 = 1, N = 20000L, burnin = 0L, thinning = 1L, vglobal = 1, verb = FALSE, icept = FALSE, standardize = TRUE, singular = FALSE) {

#      Y = as.matrix(Y)

#      X = as.matrix(X)

#      try(if(dim(Y)[1] != dim(X)[1]) stop("Length of X and Y don't agree."))

#      # scale the initial value
#      if(is.null(sigma)){
#          sigma = 0.5 * stats::sd(Y)
#      }

#      if(is.null(block_vec)){
#          block_vec = rep(1, dim(X)[2])
#      }

#      penalize = rep(1, dim(X)[2])

#      prior_type = 1L

#      user_prior_function = NULL

#     .Call('bayeslm_horseshoe', PACKAGE = 'bayeslm', Y, X, penalize, block_vec, prior_type, user_prior_function, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
# }



# blasso <- function(Y, X, block_vec = NULL, sigma = NULL, s2 = 1, kap2 = 1, N = 20000L, burnin = 0L, thinning = 1L, vglobal = 1, verb = FALSE, icept = FALSE, standardize = TRUE, singular = FALSE) {

#      Y = as.matrix(Y)

#      X = as.matrix(X)

#      try(if(dim(Y)[1] != dim(X)[1]) stop("Length of X and Y don't agree."))

#      # scale the initial value
#      if(is.null(sigma)){
#          sigma = 0.5 * stats::sd(Y)
#      }

#      if(is.null(block_vec)){
#          block_vec = rep(1, dim(X)[2])
#      }

#      penalize = rep(1, dim(X)[2])

#      prior_type = 1L


#     .Call('bayeslm_blasso', PACKAGE = 'bayeslm', Y, X, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
# }



# ridge <- function(Y, X, block_vec = NULL, sigma = NULL, s2 = 1, kap2 = 1, N = 20000L, burnin = 0L, thinning = 1L, vglobal = 1, verb = FALSE, icept = FALSE, standardize = TRUE, singular = FALSE) {

#      Y = as.matrix(Y)

#      X = as.matrix(X)

#      try(if(dim(Y)[1] != dim(X)[1]) stop("Length of X and Y don't agree."))

#      # scale the initial value
#      if(is.null(sigma)){
#          sigma = 0.5 * stats::sd(Y)
#      }

#      if(is.null(block_vec)){
#          block_vec = rep(1, dim(X)[2])
#      }

#      penalize = rep(1, dim(X)[2])

#      prior_type = 1L

#     .Call('bayeslm_ridge', PACKAGE = 'bayeslm', Y, X, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
# }




# sharkfin <- function(Y, X, prob_vec, block_vec = NULL, sigma = NULL, s2 = 1, kap2 = 1, N = 20000L, burnin = 0L, thinning = 1L, vglobal = 1, verb = FALSE, icept = FALSE, standardize = TRUE, singular = FALSE) {

#      Y = as.matrix(Y)

#      X = as.matrix(X)

#      try(if(dim(Y)[1] != dim(X)[1]) stop("Length of X and Y don't agree."))

#      # scale the initial value
#      if(is.null(sigma)){
#          sigma = 0.5 * stats::sd(Y)
#      }

#      if(is.null(block_vec)){
#          block_vec = rep(1, dim(X)[2])
#      }
     

#      penalize = rep(1, dim(X)[2])

#      prior_type = 1L


#     .Call('bayeslm_sharkfin', PACKAGE = 'bayeslm', Y, X, prob_vec, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
# }





# nonlocal <- function(Y, X, prior_mean, block_vec = NULL, sigma = NULL, s2 = 1, kap2 = 1, N = 20000L, burnin = 0L, thinning = 1L, vglobal = 1, verb = FALSE, icept = FALSE, standardize = TRUE, singular = FALSE) {

#      Y = as.matrix(Y)

#      X = as.matrix(X)

#      try(if(dim(Y)[1] != dim(X)[1]) stop("Length of X and Y don't agree."))

#      # scale the initial value
#      if(is.null(sigma)){
#          sigma = 0.5 * stats::sd(Y)
#      }

#      if(is.null(block_vec)){
#          block_vec = rep(1, dim(X)[2])
#      }

#      penalize = rep(1, dim(X)[2])

#      prior_type = 1L


#     .Call('bayeslm_nonlocal', PACKAGE = 'bayeslm', Y, X, prior_mean, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
# }




bayeslm <- function(Y, X, prior = "horseshoe", block_vec = NULL, sigma = NULL, s2 = 1, kap2 = 1, N = 20000L, burnin = 0L, thinning = 1L, vglobal = 1, verb = FALSE, icept = FALSE, standardize = TRUE, singular = FALSE, prior_mean = NULL, prob_vec = NULL){


     Y = as.matrix(Y)

     X = as.matrix(X)

     try(if(dim(Y)[1] != dim(X)[1]) stop("Length of X and Y don't agree."))

     # scale the initial value
     if(is.null(sigma)){
         sigma = 0.5 * stats::sd(Y)
     }

     if(is.null(block_vec)){
         block_vec = rep(1, dim(X)[2])
     }

     penalize = rep(1, dim(X)[2])

          prior_type = 1L

          user_prior_function = NULL
    

        if(prior == "horseshoe"){
            cat("horseshoe prior \n")
            .Call('bayeslm_horseshoe', PACKAGE = 'bayeslm', Y, X, penalize, block_vec, prior_type, user_prior_function, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
        }else if(prior == "laplace"){
            cat("laplace prior \n")
            .Call('bayeslm_blasso', PACKAGE = 'bayeslm', Y, X, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
        }else if(prior == "ridge"){
            cat("ridge prior \n")
            .Call('bayeslm_ridge', PACKAGE = 'bayeslm', Y, X, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
        }else if(prior == "nonlocal"){
            cat("nonlocal prior \n")
            if(is.null(prior_mean) == TRUE){
                cat("prior mean of nonlocal prior is not specified, use default value 1.5 for all coefficients \n")
                if(icept == TRUE){
                    prior_mean = rep(0, dim(X)[2]+1)
                }else{
                    prior_mean = rep(0, dim(X)[2])
                }
            }
            .Call('bayeslm_nonlocal', PACKAGE = 'bayeslm', Y, X, prior_mean, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
        }else if(prior == "sharkfin"){
            cat("sharkfin prior \n")
            if(is.null(prob_vec) == TRUE){
                cat("prior parameter q of nonlocal prior is not specified, use default value 0.25 for all coefficients \n")
                if(icept == TRUE){
                    prob_vec = rep(0, dim(X)[2] + 1)
                }else{
                    prob_vec = rep(0, dim(X)[2])
                }
            }
            .Call('bayeslm_sharkfin', PACKAGE = 'bayeslm', Y, X, prob_vec, penalize, block_vec, prior_type, sigma, s2, kap2, N, burnin, thinning, vglobal, verb, icept, standardize, singular)
        }else{
            cat("wrong prior \n")
        }
     
}